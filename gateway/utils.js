const axios = require("axios");
const Eris = require("eris");
const fs = require("fs");
const ws = require('ws');
const https = require("https");
axios.defaults.httpsAgent = new https.Agent({ keepAlive: true });

module.exports = class extends require("events") {
  constructor(tokens , options) {
    super();
  this.proxies = []
  this.clients = []
  this.hcaptcha = []

  this.headers = {}
  this.webhook = undefined
  this.events = true
  this.invite = undefined;
  this.tokens = []

  if(typeof options === "object") { this.invite = options.invite; this.headers = options.headers || {}; this.webhook = options.webhook; this.events = options.events || this.events}


  if(typeof tokens !== "object" || !Array.isArray(tokens)) throw new Error("tokens must be an array");
 if(this.events) { this._awaitEvents(); }

  this._start(tokens);
  this._setupProxies();
  this._setupTokens();
  }



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


_start(tokens) {
for (let token of tokens) {
let bot = new Eris(token , { restMode:true, defaultImageSize: 1024 })
this.clients.push(bot)
bot.number = this.clients.indexOf(bot)

bot.on("error" , (error) => this.emit("error" , bot.number , error))
bot.on("ready" , () => this.emit("ready" , bot.number))
bot.on("disconnect" , (error) => this.emit("disconnect" , bot.number , error))
bot.connect();
}}



getRandomUser() {
let f = this.clients.filter(c => c.ready && c.users.size > 10)

let c = f[Math.floor(Math.random()*f.length)]
if(!c) return;

let ff = c.guilds.filter(s => s.memberCount > 20)
let guild = ff[Math.floor(Math.random()*ff.length)]
if(!guild) return this.getRandomUser();

let members = guild.members.filter(member => !member.bot && !member.permissions.has("manageGuild") && member.avatar && member.avatarURL && member.avatar !== member.defaultAvatar && isNaN(member.user.username))
let member = members[Math.floor(Math.random()*members.length)]
return member ? member : this.getRandomUser();
}


_awaitEvents() {
this.on("ready" , (number) => {
let bot = this.clients[number]
console.log(`[${number}] ${bot.user.username} (${bot.user.id}) is Ready | users: ${bot.users.size}`)
})

this.on("error" , (number , error) => {
let bot = this.clients[number]
console.log(`Error! [${number}]: ${error.message}`)
})

this.on("disconnect" , (number) => {
let bot = this.clients[number]
console.log(`[${number}] disconnected!`)
})
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




getProxyArray(backup) {
let text = fs.readFileSync(`./data/${backup ? "proxies-backup" : "proxies"}.txt`, {encoding:'utf8', flag:'r'})
return text.split("\n").map(d => d.replace('https://', '').replace('.glitch.me/', ''))
}

_setupProxies(){
this.proxies = this.getProxyArray();
this.backupProxies = this.getProxyArray(true)
if(this.proxies.length < 5) { this.proxies = this.backupProxies }

console.log("Proxies: " + this.proxies.length)

setInterval(() =>{
let d = this.proxies.map(a => `https://` + a + `.glitch.me/`).join("\n")
fs.writeFile("./data/proxies.txt", d , function(err) {if(err) console.log(err)});
} , 10000)

}


getProxy() {
let domain = this.proxies.shift();
this.proxies.push(domain)
return domain
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




async getBase64(url , a) {
  return axios.get(url, { responseType: 'arraybuffer' }).then(response => `${a ? "data:text/plain;base64," : ""}${Buffer.from(response.data, 'binary').toString('base64')}`)
}


_fetch(method = "GET" , url , data = {} , headers = {}) {
return new Promise(re =>{

axios({ method , url , data , headers }).then(res =>{
if(!res) return;
re(res)
}).catch(err =>{
re(err.message)
})

})
}


async fetch(options , proxy) {
if(typeof options !== "object") return;
let method = options.method || "GET"

let url = options.url
if(!url) return; 

let data = options.data
let auth = options.auth

let heade = options.headers || this.headers
let headers = Object.assign(heade , {})
if(auth) { headers.authorization = auth }

if(proxy) {
let d = await this._fetch("POST" , proxy , { url, data , method , headers })
return d.data
}else{
let dd = await this._fetch(method , url , data , headers)
return dd.data
}

}


sendWebhook(content , proxy, webhook = this.webhook) {
if(!webhook) return;

return this.fetch({
method: "POST",
url: webhook,
data: typeof content === "string" ? { content } : content
} , proxy)

}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


async execute(options , proxy) {
if(typeof options !== "object") return;
this.headers.authorization = null
delete this.headers.authorization

let o = {
"captcha_key": options.captcha || undefined,
"consent": true,
"username": options.username || this.getRandomUser().username,
"fingerprint": options['x-fingerprint'] || this.headers['x-fingerprint'],
"gift_code_sku_id": null,
"invite": options.invite || undefined,
"promotional_email_opt_in": "ewrwerewr@gmail.com"
}


let fetch_data = await this.fetch({
method: "POST",
url: "https://discord.com/api/v7/auth/register",
headers: options.headers || this.headers,
data: o
} , proxy)
return fetch_data

}



joinServer(auth , code , proxy) {
return this.fetch({
method: "post",
url: 'https://discord.com/api/v7/invites/' + code,
auth:auth
} , proxy)
}

editProfile(auth , data , proxy) {
return this.fetch({
method: "patch",
url: 'https://discord.com/api/v7/users/@me',
data: data,
auth:auth
} , proxy)
}


hypeSquad(auth , proxy , house_id = [1,2,3][Math.floor(Math.random()*[1,2,3].length)]) {
return this.fetch({
method: "post",
url: 'https://discord.com/api/v7/hypesquad/online',
data: { house_id },
auth:auth
} , proxy)
}


addFriend(auth , data , proxy) {
return this.fetch({
method: "post",
url: 'https://discord.com/api/v7/users/@me/relationships',
data: data,
auth:auth
} , proxy)
}


/*
fetch("", {
        method: 'put',
        headers: headers,
    })
    .then(res => res.json().catch(err =>{}) || res.text())
    .then(json => {
console.log(json)
})
*/

async addReaction(auth , channelID, messageID, reaction , proxy) {
if(reaction === decodeURI(reaction)) {
  reaction = encodeURIComponent(reaction);
}

/*const fetch = require('node-fetch')

let dataFetch = await fetch((`https://discord.com/api/v7/channels/${channelID}/messages/${messageID}/reactions/${reaction}/${encodeURI(`@me`)}`), {method: "PUT"
, headers: {"content-type": "application/json;",
authorization: auth
           }})
let dataJSON = await dataFetch.json()
console.log(dataJSON)*/
return this.fetch({
url: `https://discord.com/api/v7/channels/${channelID}/messages/${messageID}/reactions/${reaction}/${encodeURI(`@me`)}`,
method: "PUT",
auth
} , proxy)




}

websocketData(token) {
return new Promise(re => {
let wss = new ws("wss://gateway.discord.gg/" , [])
wss.on("message" , async msg =>{

let m;
try {m = JSON.parse(msg)} catch { return; }

if(m.t === null){
let auth = (token) => {
  wss.token = token
  wss.send(`{"op":2,"d":{"token":"${token}","capabilities":125,"properties":{"os":"Windows","browser":"Chrome","device":"","system_locale":"ar-AE","browser_user_agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36","browser_version":"91.0.4472.101","os_version":"10","referrer":"https://discord.com/channels/793203630978498560/853614357865562123","referring_domain":"discord.com","referrer_current":"","referring_domain_current":"","release_channel":"stable","client_build_number":87709,"client_event_source":null},"presence":{"status":"online","since":0,"activities":[],"afk":false},"compress":false,"client_state":{"guild_hashes":{},"highest_last_message_id":"0","read_state_version":0,"user_guild_settings_version":-1}}}`)
}

  return auth(token)

}
if(m.t === "READY") {


var data = m.d
let user = data.user 
user.verified = data.user.verified
user.require_verified = data.required_action ? true : false
user.require_phone = data.required_action === "REQUIRE_VERIFIED_PHONE" ? true : false

re(m.d);

}
});


})
}


_setupTokens(){
fs.readFileSync('./data/tokens.txt', {encoding:'utf8', flag:'r'})
.split("\n").filter(a => a).forEach(token =>{
this.tokens.push(token)
})

setInterval(() => {
let d = this.tokens.join("\n")
fs.writeFile("./data/tokens.txt", d , function(err) {if(err) console.log(err)});
} , 3000)
}

saveToken(token, dir) {
this.emit("token" , token)
this.tokens.push(token)
if(!dir) dir = "/data/tokens.txt"
let daaaaaaa = fs.readFileSync(`.${dir}`, {encoding:'utf8', flag:'r'})
let da = daaaaaaa + "\n" + token
fs.writeFile(`.${dir}`, da, function(err) {if(err) console.log(err)});
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}




